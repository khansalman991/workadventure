import { AbortError } from "@workadventure/shared-utils/src/Abort/AbortError";
import { TimeoutError } from "@workadventure/shared-utils/src/Abort/TimeoutError";
import { abortAny } from "@workadventure/shared-utils/src/Abort/AbortAny";
import { abortTimeout } from "@workadventure/shared-utils/src/Abort/AbortTimeout";
import type { Readable, Writable } from "svelte/store";
import { derived, get, readable, writable } from "svelte/store";
import * as Sentry from "@sentry/svelte";
import { applyFieldMask } from "protobuf-fieldmask";
import type { Subscription } from "rxjs";
import { Observable, Subject } from "rxjs";
import { merge } from "lodash";
import * as DeferredModule from "ts-deferred";
const Deferred = DeferredModule.Deferred;
import { MapStore } from "@workadventure/store-utils";
import type {
    PublicEvent,
    SpaceEvent,
    UpdateSpaceMetadataMessage,
    SpaceUser,
    PrivateSpaceEvent,
    PrivateEventPusherToFront,
} from "@workadventure/messages";
import { FilterType } from "@workadventure/messages";
import { raceAbort } from "@workadventure/shared-utils/src/Abort/raceAbort";
import z from "zod";
import { CharacterLayerManager } from "../Phaser/Entity/CharacterLayerManager";
import { RemotePeer } from "../WebRtc/RemotePeer";
import type { BlackListManager } from "../WebRtc/BlackListManager";
import { blackListManager } from "../WebRtc/BlackListManager";
import { ConnectionClosedError } from "../Connection/ConnectionClosedError";
import { highlightedEmbedScreen } from "../Stores/HighlightedEmbedScreenStore";
import type { Streamable } from "../Stores/StreamableCollectionStore";
import { LAST_VIDEO_BOX_PRIORITY } from "../Stores/StreamableCollectionStore";
import type {
    PrivateEventsObservables,
    PublicEventsObservables,
    SpaceInterface,
    SpaceUserUpdate,
    UpdateSpaceUserEvent,
    ReactiveSpaceUser,
    SpaceUserExtended,
} from "./SpaceInterface";
import { SpaceNameIsEmptyError } from "./Errors/SpaceError";
import type { RoomConnectionForSpacesInterface } from "./SpaceRegistry/SpaceRegistry";
import type { SimplePeerConnectionInterface } from "./SpacePeerManager/SpacePeerManager";
import { SpacePeerManager } from "./SpacePeerManager/SpacePeerManager";
import { lookupUserById } from "./Utils/UserLookup";

export interface VideoBox {
    uniqueId: string;
    spaceUser: SpaceUserExtended;
    streamable: Writable<Streamable | undefined>;
    priority: number;
    displayOrder: Writable<number>;
    lastSpeakTimestamp?: number;
    boxStyle?: { [key: string]: unknown };
    isMegaphoneSpace?: boolean;
}

export class Space implements SpaceInterface {
    private readonly name: string;

    private readonly publicEventsObservables: PublicEventsObservables = {};
    private readonly privateEventsObservables: PrivateEventsObservables = {};
    private _onLeaveSpace = new Subject<void>();
    public readonly onLeaveSpace = this._onLeaveSpace.asObservable();
    private _peerManager: SpacePeerManager;
    public allVideoStreamStore: MapStore<string, VideoBox> = new MapStore<string, VideoBox>();
    public allScreenShareStreamStore: MapStore<string, VideoBox> = new MapStore<string, VideoBox>();
    public readonly videoStreamStore: Readable<Map<string, VideoBox>>;
    public readonly screenShareStreamStore: Readable<Map<string, VideoBox>>;
    
    private readonly _blockedUsersStore: Writable<Set<string>> = writable(new Set<string>());
    private readonly _blockedByUsersStore: Writable<Set<string>> = writable(new Set<string>());
    private readonly _allBlockedUsersStore: Readable<Set<string>> = derived(
        [this._blockedUsersStore, this._blockedByUsersStore],
        ([$blockedUsersStore, $blockedByUsersStore]) => {
            return new Set([...$blockedUsersStore, ...$blockedByUsersStore]);
        }
    );

    private _setUsers: ((value: Map<string, SpaceUserExtended>) => void) | undefined;
    private _users: Map<string, SpaceUserExtended> = new Map<string, SpaceUserExtended>();
    private _addUserSubject: Subject<SpaceUserExtended> = new Subject<SpaceUserExtended>();
    private _leftUserSubject: Subject<SpaceUserExtended> = new Subject<SpaceUserExtended>();
    private _updateUserSubject: Subject<UpdateSpaceUserEvent> = new Subject<UpdateSpaceUserEvent>();
    private _metadataSubject: Subject<Map<string, unknown>> = new Subject<Map<string, unknown>>();
    private _registerRefCount = 0;
    private isDestroyed = false;
    public readonly usersStore: Readable<Map<string, Readonly<SpaceUserExtended>>>;
    public readonly observeUserJoined: Observable<SpaceUserExtended>;
    public readonly observeUserLeft: Observable<SpaceUserExtended>;
    public readonly observeUserUpdated: Observable<UpdateSpaceUserEvent>;
    public readonly observeMetadata: Observable<Map<string, unknown>>;
    private readonly observeSyncUserAdded: Subscription;
    private readonly observeSyncUserUpdated: Subscription;
    private readonly observeSyncUserRemoved: Subscription;
    private observeVideoPeerAdded: Subscription | undefined;
    private observeScreenSharingPeerAdded: Subscription | undefined;

    private readonly _isStreamingStore: Writable<boolean>;
    private readonly observeSyncBlockUser: Subscription;
    private readonly observeSyncUnblockUser: Subscription;
    private readonly onBlockSubscribe: Subscription;
    private readonly onUnBlockSubscribe: Subscription;

    private _isDestroyed = false;
    private initPromise: DeferredModule.Deferred<void> | undefined;

    private constructor(
        name: string,
        private _metadata = new Map<string, unknown>(),
        private _connection: RoomConnectionForSpacesInterface,
        public readonly filterType: FilterType,
        private _propertiesToSync: string[] = [],
        private _mySpaceUserId: SpaceUser["spaceUserId"],
        private _blackListManager: BlackListManager = blackListManager,
        private _highlightedEmbedScreenStore = highlightedEmbedScreen
    ) {
        if (name === "") {
            throw new SpaceNameIsEmptyError();
        }
        this.name = name;

        this.usersStore = readable(new Map<string, SpaceUserExtended>(), (set) => {
            this.registerSpaceFilter();
            this._setUsers = set;
            set(this._users);

            return () => {
                if (!this.isDestroyed) {
                    this.unregisterSpaceFilter();
                }
            };
        });

        this.observeUserJoined = new Observable<SpaceUserExtended>((subscriber) => {
            this.registerSpaceFilter();
            const sub = this._addUserSubject.subscribe(subscriber);

            return () => {
                sub.unsubscribe();
                if (!this.isDestroyed) {
                    this.unregisterSpaceFilter();
                }
            };
        });

        this.observeUserLeft = new Observable<SpaceUserExtended>((subscriber) => {
            this.registerSpaceFilter();
            const sub = this._leftUserSubject.subscribe(subscriber);

            return () => {
                sub.unsubscribe();
                if (!this.isDestroyed) {
                    this.unregisterSpaceFilter();
                }
            };
        });

        this.observeUserUpdated = new Observable<UpdateSpaceUserEvent>((subscriber) => {
            this.registerSpaceFilter();
            const sub = this._updateUserSubject.subscribe(subscriber);

            return () => {
                sub.unsubscribe();
                if (!this.isDestroyed) {
                    this.unregisterSpaceFilter();
                }
            };
        });

        this.observeMetadata = new Observable<Map<string, unknown>>((subscriber) => {
            this.registerSpaceFilter();
            const sub = this._metadataSubject.subscribe(subscriber);

            return () => {
                sub.unsubscribe();
                if (!this.isDestroyed) {
                    this.unregisterSpaceFilter();
                }
            };
        });

        this.videoStreamStore = derived(
            [this.allVideoStreamStore, this.usersStore],
            ([videoStreamStore, usersStore]) => {
                const newVideoStreamStore = new Map<string, VideoBox>();
                for (const [key, value] of videoStreamStore.entries()) {
                    if (usersStore.has(key)) {
                        newVideoStreamStore.set(key, value);
                    }
                }
                return newVideoStreamStore;
            }
        );
        this.screenShareStreamStore = derived(
            [this.allScreenShareStreamStore, this.usersStore],
            ([screenShareStreamStore, usersStore]) => {
                const newScreenShareStreamStore = new Map<string, VideoBox>();
                for (const [key, value] of screenShareStreamStore.entries()) {
                    if (usersStore.has(key)) {
                        newScreenShareStreamStore.set(key, value);
                    }
                }
                return newScreenShareStreamStore;
            }
        );

        this.onBlockSubscribe = this._blackListManager.onBlockStream.subscribe((userUuid) => {
            const spaceUser = this.getSpaceUserByUuid(userUuid);

            if (!spaceUser) {
                return;
            }

            this.emitPrivateMessage(
                {
                    $case: "blockUserMessage",
                    blockUserMessage: {},
                } as any,
                spaceUser.spaceUserId
            );

            this.blockUser(spaceUser.spaceUserId);
        });

        this.onUnBlockSubscribe = this._blackListManager.onUnBlockStream.subscribe((userUuid) => {
            const spaceUser = this.getSpaceUserByUuid(userUuid);

            if (!spaceUser) {
                return;
            }

            this.emitPrivateMessage(
                {
                    $case: "unblockUserMessage",
                    unblockUserMessage: {},
                } as any,
                spaceUser.spaceUserId
            );

            this.unblockUser(spaceUser.spaceUserId);
        });

        this._blockedUsersStore.set(this._blackListManager.getBlackListedUsers());

        this._peerManager = new SpacePeerManager(this, this._allBlockedUsersStore);
        this.registerPeerManagerEventHandlers();

        this.observeSyncUserAdded = this.observePrivateEvent("addSpaceUserMessage").subscribe((message) => {
            if (!message.addSpaceUserMessage.user) {
                return;
            }
            this.addUser(message.addSpaceUserMessage.user);
        });
        this.observeSyncUserUpdated = this.observePrivateEvent("updateSpaceUserMessage").subscribe((message) => {
            if (!message.updateSpaceUserMessage.user || !message.updateSpaceUserMessage.updateMask) {
                return;
            }
            this.updateUserData(message.updateSpaceUserMessage.user, message.updateSpaceUserMessage.updateMask);
        });
        this.observeSyncUserRemoved = this.observePrivateEvent("removeSpaceUserMessage").subscribe((message) => {
            this.removeUser(message.removeSpaceUserMessage.spaceUserId);
        });

        this._isStreamingStore = writable(
            filterType === FilterType.ALL_USERS &&
                (this._propertiesToSync.includes("cameraState") ||
                    this._propertiesToSync.includes("microphoneState") ||
                    this._propertiesToSync.includes("screenSharingState"))
        );

        this.observeSyncBlockUser = this.observePrivateEvent("blockUserMessage").subscribe((message) => {
            this.blockByUser(message.sender.spaceUserId);
        });
        this.observeSyncUnblockUser = this.observePrivateEvent("unblockUserMessage").subscribe((message) => {
            this.unblockByUser(message.sender.spaceUserId);
        });
    }

    static async create(
        name: string,
        filterType: FilterType,
        connection: RoomConnectionForSpacesInterface,
        propertiesToSync: string[] = [],
        signal: AbortSignal,
        options?: {
            metadata: Map<string, unknown>;
        }
    ): Promise<Space> {
        const spaceUserId = await connection.emitJoinSpace(name, filterType, propertiesToSync, {
            signal,
        });
        return new Space(
            name,
            options?.metadata ?? new Map<string, unknown>(),
            connection,
            filterType,
            propertiesToSync,
            spaceUserId
        );
    }

    getName(): string {
        return this.name;
    }
    getMetadata(): Map<string, unknown> {
        return this._metadata;
    }
    setMetadata(metadata: Map<string, unknown>): void {
        metadata.forEach((value, key) => {
            this._metadata.set(key, value);
        });
        if (this._metadataSubject) {
            this._metadataSubject.next(this._metadata);
        }
    }

    private async userLeaveSpace() {
        if (this._connection.closed) {
            return;
        }
        await this._connection.emitLeaveSpace(this.name);
    }

    public emitUpdateSpaceMetadata(metadata: Map<string, unknown>) {
        if (this._isDestroyed) {
            return;
        }
        this._connection.emitUpdateSpaceMetadata(this.name, Object.fromEntries(metadata.entries()));
    }

    public observePublicEvent<K extends keyof PublicEventsObservables>(
        key: K
    ): NonNullable<PublicEventsObservables[K]> {
        const observable = this.publicEventsObservables[key];
        if (!observable) {
            return (this.publicEventsObservables[key] = new Subject() as NonNullable<PublicEventsObservables[K]>);
        }
        return observable;
    }
    public observePrivateEvent<K extends keyof PrivateEventsObservables>(
        key: K
    ): NonNullable<PrivateEventsObservables[K]> {
        const observable = this.privateEventsObservables[key];
        if (!observable) {
            return (this.privateEventsObservables[key] = new Subject() as NonNullable<PrivateEventsObservables[K]>);
        }
        return observable;
    }

    public dispatchPublicMessage(message: PublicEvent) {
        const spaceEvent = message.spaceEvent;
        if (spaceEvent === undefined) {
            throw new Error("Received a message without spaceEvent");
        }
        
        const sender = message.senderUserId;
        const sEvent = spaceEvent as any;
        const subject = this.publicEventsObservables[sEvent.$case];
        if (subject) {
            subject.next({
                spaceName: message.spaceName,
                sender,
                ...sEvent,
            } as any);
        }
    }

    public dispatchPrivateMessage(message: PrivateEventPusherToFront) {
        const spaceEvent = message.spaceEvent;
        if (spaceEvent === undefined) {
            throw new Error("Received a message without spaceEvent");
        }
        
        const sender = message.sender;
        if (sender === undefined) {
            throw new Error("Received a message without senderUserId");
        }

        const sEvent = spaceEvent as any;
        const subject = this.privateEventsObservables[sEvent.$case];
        if (subject) {
            subject.next({
                spaceName: message.spaceName,
                sender,
                ...sEvent,
            } as any);
        }
    }

    /**
     * FIXED: Property 'event' does not exist on type 'SpaceEvent'.
     * In the flattened structure, the message passed to emitPublicSpaceEvent
     * is the event itself.
     */
    public emitPublicMessage(message: any): void {
        if (this._isDestroyed) {
            return;
        }
        this._connection.emitPublicSpaceEvent(this.name, message);
    }

    /**
     * FIXED: Property 'event' does not exist on type 'PrivateSpaceEvent'.
     */
    public emitPrivateMessage(message: any, receiverUserId: string): void {
        if (this._isDestroyed) {
            return;
        }
        this._connection.emitPrivateSpaceEvent(this.name, message, receiverUserId);
    }

    public emitUpdateUser(spaceUser: SpaceUserUpdate): void {
        if (this._isDestroyed) {
            return;
        }
        this._connection.emitUpdateSpaceUserMessage(this.name, spaceUser);
    }

    async destroy() {
        this._isDestroyed = true;

        this.retryAbortController?.abort();
        if (this.retryTimeout) {
            clearTimeout(this.retryTimeout);
        }

        try {
            await this.userLeaveSpace();
        } catch (e) {
            if (!(e instanceof ConnectionClosedError)) {
                Sentry.captureException(e);
            }
        }

        for (const subscription of Object.values(this.publicEventsObservables)) {
            if (subscription) subscription.complete();
        }
        for (const subscription of Object.values(this.privateEventsObservables)) {
            if (subscription) subscription.complete();
        }
        this._onLeaveSpace.next();
        this._onLeaveSpace.complete();
        this.observeSyncUserAdded.unsubscribe();
        this.observeSyncUserUpdated.unsubscribe();
        this.observeSyncUserRemoved.unsubscribe();
        this.observeVideoPeerAdded?.unsubscribe();
        this.observeScreenSharingPeerAdded?.unsubscribe();
        this.onBlockSubscribe.unsubscribe();
        this.onUnBlockSubscribe.unsubscribe();
        this.observeSyncBlockUser.unsubscribe();
        this.observeSyncUnblockUser.unsubscribe();

        this._peerManager.destroy();

        this.allVideoStreamStore.forEach((peer) => {
            const streamable = get(peer.streamable);
            if (streamable instanceof RemotePeer) {
                streamable.destroy();
            }
        });

        this.allScreenShareStreamStore.forEach((peer) => {
            const streamable = get(peer.streamable);
            if (streamable instanceof RemotePeer) {
                streamable.destroy();
            }
        });

        if (this._registerRefCount > 0) {
            this.unregisterSpaceFilter();
        }

        this.isDestroyed = true;
    }

    get simplePeer(): SimplePeerConnectionInterface | undefined {
        return this._peerManager.getPeer();
    }

    get spacePeerManager(): SpacePeerManager {
        return this._peerManager;
    }

    watchSpaceMetadata(): Observable<UpdateSpaceMetadataMessage> {
        return this._connection.updateSpaceMetadataMessageStream;
    }

    initUsers(users: SpaceUser[]): void {
        for (const user of users) {
            const extendSpaceUser = this.extendSpaceUser(user);
            if (!this._users.has(user.spaceUserId)) {
                if (this.isVideoSpace() && user.spaceUserId !== this._mySpaceUserId) {
                    const videoBox = this.getEmptyVideoBox(extendSpaceUser);
                    const streamable = this.spacePeerManager.getVideoForUser(user.spaceUserId);
                    if (streamable) {
                        videoBox.streamable.set(streamable);
                    }
                    this.allVideoStreamStore.set(user.spaceUserId, videoBox);

                    if (this._blackListManager.isBlackListed(user.spaceUserId)) {
                        this.emitPrivateMessage(
                            {
                                $case: "blockUserMessage",
                                blockUserMessage: {},
                            } as any,
                            user.spaceUserId
                        );
                    }

                    if (user.screenSharingState) {
                        const videoBox = this.getEmptyVideoBox(extendSpaceUser, true);
                        const streamable = this.spacePeerManager.getScreenSharingForUser(user.spaceUserId);
                        if (streamable) {
                            videoBox.streamable.set(streamable);
                        }
                        this.allScreenShareStreamStore.set(user.spaceUserId, videoBox);
                    }
                }

                this._users.set(user.spaceUserId, extendSpaceUser);
                if (this._addUserSubject) {
                    this._addUserSubject.next(extendSpaceUser);
                }
            }
        }

        this._setUsers?.(this._users);
        this.initPromise?.resolve();
    }

    addUser(user: SpaceUser): SpaceUserExtended {
        const extendSpaceUser = this.extendSpaceUser(user);

        if (!this._users.has(user.spaceUserId)) {
            if (this.isVideoSpace() && user.spaceUserId !== this._mySpaceUserId) {
                const streamable = this.spacePeerManager.getVideoForUser(user.spaceUserId);
                const videoBox = this.getEmptyVideoBox(extendSpaceUser);

                if (streamable) {
                    videoBox.streamable.set(streamable);
                }
                this.allVideoStreamStore.set(user.spaceUserId, videoBox);

                if (this._blackListManager.isBlackListed(user.spaceUserId)) {
                    this.emitPrivateMessage(
                        {
                            $case: "blockUserMessage",
                            blockUserMessage: {},
                        } as any,
                        user.spaceUserId
                    );
                }
            }
            this._users.set(user.spaceUserId, extendSpaceUser);
            if (this._setUsers) {
                this._setUsers(this._users);
            }

            if (this._addUserSubject) {
                this._addUserSubject.next(extendSpaceUser);
            }
        }

        return extendSpaceUser;
    }

    removeUser(spaceUserId: string): void {
        const user = this._users.get(spaceUserId);
        if (user) {
            this._users.delete(spaceUserId);
            if (this._setUsers) {
                this._setUsers(this._users);
            }
            if (this._leftUserSubject) {
                this._leftUserSubject.next(user);
            }

            this.allVideoStreamStore.delete(spaceUserId);
            this.allScreenShareStreamStore.delete(spaceUserId);
        }
    }

    updateUserData(newData: SpaceUser, updateMask: string[]): void {
        if (!newData.spaceUserId && newData.spaceUserId !== "") return;

        const userToUpdate = this._users.get(newData.spaceUserId);

        if (!userToUpdate) return;

        const maskedNewData = applyFieldMask(newData, updateMask) as unknown as Partial<SpaceUser>;

        merge(userToUpdate, maskedNewData);

        for (const key in maskedNewData) {
            const castKey = key as keyof typeof newData;
            if (castKey in userToUpdate.reactiveUser) {
                const store = userToUpdate.reactiveUser[castKey];
                if (typeof store === "object" && "set" in store) {
                    (store as Writable<unknown>).set(newData[castKey]);
                }
            }
        }

        if (this._updateUserSubject) {
            this._updateUserSubject.next({
                newUser: userToUpdate,
                changes: maskedNewData,
                updateMask: updateMask,
            });
        }

        if (maskedNewData.screenSharingState !== undefined && userToUpdate.spaceUserId !== this._mySpaceUserId) {
            if (maskedNewData.screenSharingState) {
                const videoBox = this.getEmptyVideoBox(userToUpdate, true);
                const streamable = this._peerManager.getScreenSharingForUser(userToUpdate.spaceUserId);
                if (streamable) {
                    videoBox.streamable.set(streamable);
                }

                this.allScreenShareStreamStore.set(userToUpdate.spaceUserId, videoBox);
                this._highlightedEmbedScreenStore.toggleHighlight(videoBox);
            } else {
                this.allScreenShareStreamStore.delete(userToUpdate.spaceUserId);
            }
        }
    }

    /**
     * FIXED: Property 'event' does not exist on type 'PrivateSpaceEvent'.
     */
    private extendSpaceUser(user: SpaceUser): SpaceUserExtended {
        const extendedUser = {
            ...user,
            pictureStore: readable<string | undefined>(undefined, (set) => {
                CharacterLayerManager.wokaBase64(user.characterTextures)
                    .then((wokaBase64) => {
                        set(wokaBase64);
                    })
                    .catch((e) => {
                        Sentry.captureException(e);
                    });
            }),

            emitPrivateEvent: (message: any) => {
                if (this._isDestroyed) {
                    return;
                }
                this._connection.emitPrivateSpaceEvent(this.getName(), message, user.spaceUserId);
            },
            space: this,
            reactiveUser: undefined as unknown as ReactiveSpaceUser,
        } as SpaceUserExtended;

        extendedUser.reactiveUser = new Proxy(
            {
                spaceUserId: extendedUser.spaceUserId,
                roomName: extendedUser.roomName,
                playUri: extendedUser.playUri,
            } as unknown as ReactiveSpaceUser,
            {
                get(target: any, property: PropertyKey, receiver: unknown) {
                    if (typeof property !== "string") {
                        return Reflect.get(target, property, receiver);
                    }

                    if (target[property as keyof ReactiveSpaceUser]) {
                        return target[property as keyof ReactiveSpaceUser];
                    } else {
                        if (property in extendedUser) {
                            target[property] = writable(extendedUser[property as keyof SpaceUserExtended]);
                            return target[property];
                        } else {
                            return Reflect.get(target, property, receiver);
                        }
                    }
                },
            }
        );

        return extendedUser;
    }

    private unregisterSpaceFilter() {
        if (this._isDestroyed) {
            return;
        }
        this._registerRefCount--;
        if (this._registerRefCount === 0) {
            this._connection.emitRemoveSpaceFilter({
                spaceFilterMessage: {
                    spaceName: this.getName(),
                },
            } as any);
            if (this.initPromise) {
                this.initPromise.promise.catch(() => {});
                this.initPromise.reject();
                this.initPromise = undefined;
            }
        }
    }

    private registerSpaceFilter() {
        if (this._isDestroyed) {
            return;
        }
        if (this._registerRefCount === 0) {
            this._connection.emitAddSpaceFilter({
                spaceFilterMessage: {
                    spaceName: this.getName(),
                },
            } as any);
            if (this.initPromise) {
                this.initPromise.promise.catch(() => {});
                this.initPromise.reject();
            }
            this.initPromise = new DeferredModule.Deferred<void>();
            this.initPromise.promise.catch(() => {});
        }
        this._registerRefCount++;
    }

    public getSpaceUserBySpaceUserId(id: string): SpaceUserExtended | undefined {
        return this._users.get(id);
    }

    public getSpaceUserByUuid(uuid: string): SpaceUserExtended | undefined {
        return Array.from(this._users.values())
            .filter((user) => {
                return this.mySpaceUserId !== user.spaceUserId;
            })
            .find((user) => user.uuid === uuid);
    }

    public getSpaceUserByUserId(id: number): SpaceUserExtended | undefined {
        return lookupUserById(id, this);
    }

    public getScreenSharingPeerVideoBox(id: SpaceUser["spaceUserId"]): VideoBox | undefined {
        return this.allScreenShareStreamStore.get(id);
    }
    public getVideoPeerVideoBox(id: SpaceUser["spaceUserId"]): VideoBox | undefined {
        return this.allVideoStreamStore.get(id);
    }

    public async dispatchSound(url: URL): Promise<void> {
        await this.spacePeerManager.dispatchSound(url);
    }

    public getPropertiesToSync(): string[] {
        return this._propertiesToSync;
    }

    public get mySpaceUserId(): SpaceUser["spaceUserId"] {
        return this._mySpaceUserId;
    }

    public async getUsers(options?: { signal: AbortSignal }): Promise<Map<string, Readonly<SpaceUserExtended>>> {
        this.registerSpaceFilter();

        setTimeout(() => {
            if (!this.isDestroyed) {
                this.unregisterSpaceFilter();
            }
        }, 0);

        if (!this.initPromise) {
            throw new Error("initPromise is not defined");
        }

        await raceAbort(this.initPromise.promise, options?.signal);

        return this._users;
    }

    public isVideoSpace(): boolean {
        return this._propertiesToSync.some((prop) =>
            ["cameraState", "microphoneState", "screenSharingState"].includes(prop)
        );
    }

    private getEmptyVideoBox(user: SpaceUserExtended, isScreenSharing: boolean = false): VideoBox {
        const metadata = z
            .object({
                isMegaphoneSpace: z.boolean().default(false),
            })
            .parse(Object.fromEntries(this.getMetadata().entries()));
        return {
            uniqueId: isScreenSharing ? "screensharing_" + user.spaceUserId : user.spaceUserId,
            spaceUser: user,
            streamable: writable(undefined),
            displayOrder: writable(9999),
            priority: LAST_VIDEO_BOX_PRIORITY,
            isMegaphoneSpace: metadata.isMegaphoneSpace,
        };
    }

    public startStreaming() {
        if (this.filterType === FilterType.ALL_USERS) {
            throw new Error("Cannot start streaming in a ALL_USERS space");
        }
        this.emitUpdateUser({
            megaphoneState: true,
        });
        this._isStreamingStore.set(true);
    }

    public stopStreaming() {
        if (this.filterType === FilterType.ALL_USERS) {
            throw new Error("Cannot stop streaming in a ALL_USERS space");
        }
        this.emitUpdateUser({
            megaphoneState: false,
        });
        this._isStreamingStore.set(false);
    }

    get isStreamingStore(): Readable<boolean> {
        return this._isStreamingStore;
    }

    private blockUser(spaceUserId: string): void {
        this._blockedUsersStore.update((blockedUsers) => {
            blockedUsers.add(spaceUserId);
            return blockedUsers;
        });
    }

    private unblockUser(spaceUserId: string): void {
        this._blockedUsersStore.update((blockedUsers) => {
            blockedUsers.delete(spaceUserId);
            return blockedUsers;
        });
    }

    private blockByUser(spaceUserId: string): void {
        this._blockedByUsersStore.update((blockedByUsers) => {
            blockedByUsers.add(spaceUserId);
            return blockedByUsers;
        });
    }

    private unblockByUser(spaceUserId: string): void {
        this._blockedByUsersStore.update((blockedByUsers) => {
            blockedByUsers.delete(spaceUserId);
            return blockedByUsers;
        });
    }

    public get destroyed(): boolean {
        return this._isDestroyed;
    }

    public onDisconnect() {
        const users = Array.from(this._users.values());
        for (const user of users) {
            this.removeUser(user.spaceUserId);
        }

        this._peerManager.destroy();
        this._peerManager = new SpacePeerManager(this, this._allBlockedUsersStore);
        this.registerPeerManagerEventHandlers();

        this.reconnect();
    }

    private retryAbortController: AbortController | undefined = undefined;
    private retryTimeout: ReturnType<typeof setTimeout> | undefined = undefined;

    private reconnect() {
        if (this.retryAbortController) {
            this.retryAbortController.abort(new AbortError());
        }
        if (this.retryTimeout) {
            clearTimeout(this.retryTimeout);
        }

        this.retryAbortController = new AbortController();
        const signal = abortAny([
            this.retryAbortController.signal,
            abortTimeout(5000, new TimeoutError("Operation timed out")),
        ]);

        (async () => {
            await this._connection.emitJoinSpace(
                this.name,
                this.filterType,
                this._propertiesToSync,
                {
                    signal,
                }
            );

            if (this._registerRefCount !== 0) {
                this._connection.emitAddSpaceFilter({
                    spaceFilterMessage: {
                        spaceName: this.getName(),
                    },
                } as any);
            }
        })().catch((e) => {
            if (!(e instanceof AbortError && !(e instanceof TimeoutError))) {
                this.retryTimeout = setTimeout(() => {
                    this.reconnect();
                }, 5000);
            }
        });
    }

    private registerPeerManagerEventHandlers() {
        this.observeVideoPeerAdded?.unsubscribe();
        this.observeVideoPeerAdded = this._peerManager.videoPeerAdded.subscribe((peer) => {
            const spaceUserId = peer.spaceUserId;
            if (!spaceUserId) return;

            const videoBox = this.getVideoPeerVideoBox(spaceUserId);
            if (!videoBox) return;

            try {
                const previousStreamable = get(videoBox.streamable);
                previousStreamable?.closeStreamable();
            } catch (e) {
                Sentry.captureException(e);
            }

            videoBox.streamable.set(peer);
        });

        this.observeScreenSharingPeerAdded?.unsubscribe();
        this.observeScreenSharingPeerAdded = this._peerManager.screenSharingPeerAdded.subscribe((peer) => {
            const spaceUserId = peer.spaceUserId;
            if (spaceUserId === this._mySpaceUserId || !spaceUserId) return;

            const videoBox = this.getScreenSharingPeerVideoBox(spaceUserId);
            if (!videoBox) return;

            videoBox.streamable.set(peer);
            this._highlightedEmbedScreenStore.toggleHighlight(videoBox);
        });
    }
}