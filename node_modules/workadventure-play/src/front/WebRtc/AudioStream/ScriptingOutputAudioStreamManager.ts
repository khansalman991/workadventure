import * as DeferredModule from "ts-deferred";
const Deferred = DeferredModule.Deferred;
/**
 * FIXED: Explicitly import the type interface to avoid using the value as a type.
 */
import type { Deferred as DeferredInterface } from "ts-deferred";
import { iframeListener } from "../../Api/IframeListener";
import { customWebRTCLogger } from "../CustomWebRTCLogger";
import type { SpaceInterface } from "../../Space/SpaceInterface";
import { OutputPCMStreamer } from "./OutputPCMStreamer";

/**
 * Class in charge of receiving audio streams from the scripting API and playing them.
 */
export class ScriptingOutputAudioStreamManager {
    /**
     * FIXED: Changed type to DeferredInterface to resolve the "value used as type" error.
     */
    private pcmStreamerDeferred: DeferredInterface<OutputPCMStreamer> = new Deferred<OutputPCMStreamer>();
    private pcmStreamerResolved = false;
    private pcmStreamerResolving = false;

    constructor(space: SpaceInterface) {
        iframeListener.registerAnswerer("startStreamInBubble", async (message) => {
            if (this.pcmStreamerResolved || this.pcmStreamerResolving) {
                throw new Error("A stream is already running");
            }
            const pcmStreamer = new OutputPCMStreamer(message.sampleRate);
            this.pcmStreamerResolving = true;
            await pcmStreamer.initWorklet();
            this.pcmStreamerResolved = true;
            this.pcmStreamerResolving = false;
            this.pcmStreamerDeferred.resolve(pcmStreamer);
            space.spacePeerManager.dispatchStream(pcmStreamer.getMediaStream());
        });

        iframeListener.registerAnswerer("appendPCMData", async (message) => {
            const pcmStreamer = await this.pcmStreamerDeferred.promise;
            await pcmStreamer.appendPCMData(message.data);
        });

        iframeListener.registerAnswerer("stopStreamInBubble", () => {
            if (this.pcmStreamerResolved || this.pcmStreamerResolving) {
                this.pcmStreamerDeferred.promise
                    .then((pcmStreamer: OutputPCMStreamer) => {
                        pcmStreamer.close();
                    })
                    .catch((e: unknown) => {
                        console.error("Error while stopping stream", e);
                    });
            } else {
                console.error("stopStreamInBubble called while no stream is running");
            }
            this.pcmStreamerResolved = false;
            this.pcmStreamerResolving = false;
            this.pcmStreamerDeferred = new Deferred<OutputPCMStreamer>();
        });

        iframeListener.registerAnswerer("resetAudioBuffer", async () => {
            customWebRTCLogger.info("Resetting audio buffer");
            const pcmStreamer = await this.pcmStreamerDeferred.promise;
            pcmStreamer.resetAudioBuffer();
        });
    }

    public close(): void {
        iframeListener.unregisterAnswerer("startStreamInBubble");
        iframeListener.unregisterAnswerer("stopStreamInBubble");
        iframeListener.unregisterAnswerer("resetAudioBuffer");
        iframeListener.unregisterAnswerer("appendPCMData");

        if (this.pcmStreamerResolved || this.pcmStreamerResolving) {
            this.pcmStreamerDeferred.promise
                /**
                 * FIXED: Added explicit types to parameters to satisfy strict "any" checks.
                 */
                .then((pcmStreamer: OutputPCMStreamer) => {
                    pcmStreamer.close();
                })
                .catch((e: unknown) => {
                    console.error("Error while closing stream", e);
                });
        }
    }
}