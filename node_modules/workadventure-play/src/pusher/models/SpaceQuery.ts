import type { SpaceAnswerMessage, SpaceQueryMessage } from "@workadventure/messages";
import * as catchUnknown from "catch-unknown";
const asError = catchUnknown.asError;
import type { Space } from "./Space";

/**
 * Type Guard to ensure $case exists on the message.
 * This solves the "Property $case does not exist" error globally in this file.
 */
function hasCase(msg: unknown): msg is { $case: string } {
    return typeof msg === "object" && msg !== null && "$case" in msg;
}

export class Query {
    private readonly _queries = new Map<
        number,
        {
            answerType: string;
            resolve: (message: SpaceAnswerMessage) => void;
            reject: (e: unknown) => void;
        }
    >();
    private _lastQueryId = 0;

    constructor(private readonly _space: Space) {}

    public async send<T extends SpaceQueryMessage>(
        message: T,
        options?: {
            timeout?: number;
            signal?: AbortSignal;
        }
    ): Promise<SpaceAnswerMessage> {
        const connection = await this._space.spaceStreamToBackPromise;
        if (!connection || connection.closed) {
            throw new Error("Connection to the back is closed");
        }

        const signals: AbortSignal[] = [];
        if (options?.signal) signals.push(options.signal);
        const timeout = options?.timeout ?? 10000;
        signals.push(AbortSignal.timeout(timeout));
        const finalSignal = AbortSignal.any(signals);

        // Cast to 'any' briefly to check $case without TSC complaining, 
        // or use the hasCase guard.
        if (!hasCase(message) || !message.$case.endsWith("Query")) {
            throw new Error("Query types are supposed to be suffixed with Query");
        }

        return new Promise((resolve, reject) => {
            if (finalSignal.aborted) {
                reject(asError(finalSignal.reason));
                return;
            }
            
            const answerType = message.$case.substring(0, message.$case.length - 5) + "Answer";

            this._queries.set(this._lastQueryId, {
                answerType,
                resolve,
                reject,
            });

            this._space.forwarder.forwardMessageToSpaceBack({
                $case: "spaceQueryMessage",
                spaceQueryMessage: {
                    id: this._lastQueryId,
                    spaceName: this._space.name,
                    query: message,
                },
            });

            finalSignal.addEventListener(
                "abort",
                () => {
                    reject(asError(finalSignal.reason));
                    this._queries.delete(this._lastQueryId);
                },
                { once: true }
            );

            this._lastQueryId++;
        });
    }

    public receiveAnswer(queryId: number, answer: SpaceAnswerMessage) {
        if (!answer) {
            throw new Error("Invalid message received. Answer missing.");
        }

        const query = this._queries.get(queryId);
        if (!query) return;

        /**
         * FIX: We check if answer is an error AND that the error property exists.
         * Using 'as any' here is a safe bypass because we are strictly checking the string value first.
         */
        const tempAnswer = answer as any;

        if (tempAnswer.$case === "error") {
            const errorMsg = tempAnswer.error?.message ?? "Unknown error from back";
            query.reject(new Error("Error received from the back: " + errorMsg));
        } else {
            query.resolve(answer);
        }

        this._queries.delete(queryId);
    }

    public destroy() {
        for (const query of this._queries.values()) {
            query.reject(new Error("Query cancelled because the space is being destroyed"));
        }
    }
}